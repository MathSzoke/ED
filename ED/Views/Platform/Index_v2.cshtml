@model dynamic

<style>
    /* Seus estilos CSS permanecem os mesmos */
    #tree-container {
        width: 100%;
        height: 100%;
        background-color: #f5f5f5;
    }

    #button-container {
        position: absolute;
        top: 10px;
        right: 10px;
        display: flex;
        gap: 10px;
        flex-direction: column;
    }

    #fill-position-window, #add-employee-window {
        position: absolute;
        bottom: 50%;
        left: 50%;
        background: white;
        padding: 20px;
        border-radius: 10px;
        box-shadow: 0px 0px 10px rgba(0, 0, 0, 0.3);
        display: none;
        width: 400px;
        height: fit-content;
        z-index: 100;
        text-align: center;
    }

        #fill-position-window select,
        #add-employee-window select,
        #add-employee-window input {
            width: 100%;
            margin-top: 10px;
            display: ruby;
        }
</style>

<div id="container" style="position: relative; width: 100%; height: 100%;">
    <div id="tree-container"></div>
    <div id="button-container">
        <button type="button" title="Zoom In" class="btn" onclick="window.PlatformCanvas.zoom(1.1)"><i class="bi bi-zoom-in"></i></button>
        <button type="button" title="Zoom Out" class="btn" onclick="window.PlatformCanvas.zoom(0.9)"><i class="bi bi-zoom-out"></i></button>
        <button type="button" title="Fullscreen" class="btn" onclick="window.PlatformCanvas.toggleFullscreen()"><i class="bi bi-fullscreen"></i></button>
        <button type="button" title="Girar" class="btn" onclick="window.PlatformCanvas.toggleOrientation()"><i class="bi bi-arrow-clockwise"></i></button>
    </div>
</div>

<script>
    // Namespace global para o canvas
    window.PlatformCanvas = window.PlatformCanvas || {};

    // Limpeza do canvas anterior
    if (window.PlatformCanvas.stage) {
        window.PlatformCanvas.stage.destroy();
    }

    // Configurações dentro do namespace
    window.PlatformCanvas.config = {
        orientation: 'vertical',
        nodeWidth: 200,
        nodeHeight: 200,
        minHorizontalSpacing: 50,
        verticalSpacing: 100,
        card: {
            cornerRadius: 4,
            shadow: {
                blur: 5,
                opacity: 0.2
            },
            isVacant: {
                fill: '#e04f60',
                text: {
                    content: "Clique aqui para preencher a posição",
                    fontStyle: 'normal'
                },
            },
            fill: {
                'PlatformManager': '#cc092f',
                'ManagementManager': '#e03c50',
                'RelationshipManager': '#e03c50',
                'Assistant': '#e03c50',
                'Diff': '#e04f60'
            },
            text: {
                color: '#fff',
                fontSize: 12,
                align: 'center',
                verticalAlign: 'middle',
                fontStyle: 'bold'
            },
            infoButton: {
                fill: 'rgba(52, 152, 219, 0.5)',
                name: 'info-button',
                infoText: {
                    fill: 'white',
                    name: 'info-text',
                    text: 'i',
                    fontSize: 20
                }
            },
            line: {
                hover: {
                    width: 3,
                    color: '',
                    shadowBlur: 10,
                },
                unhover: {
                    width: 2,
                    color: '',
                    shadowBlur: 5,
                },
            },
            stroke: {
                color: '#ecf0f1',
                width: 2
            }
        },
        lineColor: '#7f8c8d',
        isHub: {
            stroke: {
                color: '#2ecc71',
                width: 3
            },
            text: {
                align: 'left',
                color: '#2ecc71',
                fontSize: 14,
                fontStyle: 'bold',
                padding: 5,
                fontFamily: 'Calibri'
            }
        },
        addButton: {
            size: 20,
            lineLength: 30,
            strokeColor: 'black',
            backGround: {
                hover: '#dee2e6',
                natural: 'transparent'
            },
            icon: {
                fill: 'black',
                align: 'center',
                text: '\uF4FE',
                fontSize: 18,
                fontFamily: 'bootstrap-icons'
            }
        }
    };

    window.PlatformCanvas.orgData = @Html.Raw(Json.Encode(Model));

    // Inicialização do canvas
    window.PlatformCanvas.container = document.getElementById('tree-container');
    window.PlatformCanvas.stage = new Konva.Stage({
        container: 'tree-container',
        width: window.PlatformCanvas.container.clientWidth,
        height: window.PlatformCanvas.container.clientHeight,
        draggable: true
    });

    window.PlatformCanvas.layer = new Konva.Layer();
    window.PlatformCanvas.stage.add(window.PlatformCanvas.layer);

    window.PlatformCanvas.occupiedPositions = new Map();

    // Todas as funções dentro do namespace
    window.PlatformCanvas.checkCollision = function(x, y, level) {
        const key = `${level}-${x.toFixed(0)}`;
        if (window.PlatformCanvas.occupiedPositions.has(key)) {
            const existingY = window.PlatformCanvas.occupiedPositions.get(key);
            if (Math.abs(existingY - y) < window.PlatformCanvas.config.nodeHeight + 20) {
                return true;
            }
        }
        window.PlatformCanvas.occupiedPositions.set(key, y);
        return false;
    };

    window.PlatformCanvas.checkCollisionHorizontal = function(x, y, level) {
        const key = `${level}-${y.toFixed(0)}`;
        if (window.PlatformCanvas.occupiedPositions.has(key)) {
            const existingX = window.PlatformCanvas.occupiedPositions.get(key);
            if (Math.abs(existingX - x) < window.PlatformCanvas.config.nodeWidth + 20) {
                return true;
            }
        }
        window.PlatformCanvas.occupiedPositions.set(key, x);
        return false;
    };

    window.PlatformCanvas.generateUniqueId = function() {
        return Math.random().toString(36).substr(2, 9);
    };

    window.PlatformCanvas.createAddButton = function(parentGroup, parentX, parentY, parentWidth, parentHeight, onClick, position = 'bottom', cardData) {
        const buttonId = window.PlatformCanvas.generateUniqueId();
        const buttonGroup = new Konva.Group({ draggable: false, name: `add-employee-button-${buttonId}` });

        let buttonX, buttonY, linePoints;

        switch (position) {
            case 'left':
                buttonX = parentX - window.PlatformCanvas.config.addButton.size - 30;
                buttonY = parentY + parentHeight / 2;
                linePoints = [parentX, buttonY, buttonX + window.PlatformCanvas.config.addButton.size - 10, buttonY];
                break;
            case 'right':
                buttonX = parentX + parentWidth + window.PlatformCanvas.config.addButton.size + 30;
                buttonY = parentY + parentHeight / 2;
                linePoints = [parentX + parentWidth, buttonY, buttonX - window.PlatformCanvas.config.addButton.size + 10, buttonY];
                break;
            case 'top':
                buttonX = parentX + parentWidth / 2;
                buttonY = parentY - window.PlatformCanvas.config.addButton.lineLength;
                linePoints = [buttonX, parentY, buttonX, buttonY + window.PlatformCanvas.config.addButton.size / 2];
                break;
            default: // bottom
                buttonX = parentX + parentWidth / 2;
                buttonY = parentY + parentHeight + window.PlatformCanvas.config.addButton.lineLength;
                linePoints = [buttonX, parentY + parentHeight, buttonX, buttonY - window.PlatformCanvas.config.addButton.size / 2];
        }

        const line = new Konva.Line({
            points: linePoints,
            stroke: window.PlatformCanvas.config.lineColor,
            strokeWidth: window.PlatformCanvas.config.lineWidth,
            lineCap: 'round'
        });

        const circle = new Konva.Circle({
            x: buttonX,
            y: buttonY,
            radius: window.PlatformCanvas.config.addButton.size / 2,
            fill: window.PlatformCanvas.config.addButton.backGround.natural,
            stroke: window.PlatformCanvas.config.addButton.strokeColor,
            strokeWidth: 1,
        });

        const plusIcon = new Konva.Text({
            x: buttonX - 9,
            y: buttonY - 10,
            text: window.PlatformCanvas.config.addButton.icon.text,
            fontFamily: window.PlatformCanvas.config.addButton.icon.fontFamily,
            fontSize: window.PlatformCanvas.config.addButton.icon.fontSize,
            fill: window.PlatformCanvas.config.addButton.icon.fill,
            align: window.PlatformCanvas.config.addButton.icon.align
        });

        buttonGroup.add(line);
        buttonGroup.add(circle);
        buttonGroup.add(plusIcon);

        buttonGroup.on('mouseenter', () => {
            window.PlatformCanvas.stage.container().style.cursor = 'pointer';
            circle.fill(window.PlatformCanvas.config.addButton.backGround.hover);
            window.PlatformCanvas.layer.batchDraw();
        });

        buttonGroup.on('mouseleave', () => {
            window.PlatformCanvas.stage.container().style.cursor = 'move';
            circle.fill(window.PlatformCanvas.config.addButton.color);
            window.PlatformCanvas.layer.batchDraw();
        });

        buttonGroup.on('click', (e) => {
            e.cancelBubble = true;
            const parentNode = cardData.employeeData;
            window.PlatformCanvas.openAddEmployeeWindow(
                parentNode.Function.ParentID,
                parentNode.PositionCode,
                parentNode.Junction
            );
        });

        window.PlatformCanvas.layer.add(buttonGroup);
        return buttonGroup;
    };

    window.PlatformCanvas.openAddEmployeeWindow = function(parentId, positionCode, junction) {
        $('#add-employee-window').remove();

        const addWindow = $(`
            <div id="add-employee-window">
                <h5>Adicionar uma nova posição</h5>
                <div class="mt-3 mb-3">
                    <label for="positionSelect" class="noSelect">Selecione uma função:</label>
                    <select class="form-select position-select" id="positionSelect">
                        <option value="">Selecione a função</option>
                    </select>
                </div>
                <div class="mt-3 mb-3">
                    <div class="mt-3 mb-3">
                        <label class="noSelect" for="reasonToCreate">Digite o motivo de criar a posição:</label>
                        <textarea class="form-control" id="reasonToCreate" rows="3"></textarea>
                    </div>
                    <div class="mt-3 mb-3">
                        <label for="positionStatus" class="noSelect">Selecione o status da posição:</label>
                        <select class="form-select" id="positionStatus">
                            <option value="">Selecione o status</option>
                        </select>
                    </div>
                </div>
                <div class="d-flex justify-content-between mt-3">
                    <button type="button" class="btn btn-success confirm-button" disabled>
                        <i class="bi bi-check"></i> Confirmar
                    </button>
                    <button type="button" class="btn btn-danger cancel-button">
                        <i class="bi bi-x"></i> Cancelar
                    </button>
                </div>
            </div>
        `);

        $('#container').append(addWindow);
        $('#add-employee-window').toggle();

        const $addWindow = $('#add-employee-window');
        const $functionSelect = $addWindow.find('.function-select');
        const $confirmButton = $addWindow.find('.confirm-button');
        const $cancelButton = $addWindow.find('.cancel-button');
        const $textareaReason = $addWindow.find('#reasonToCreate');
        const $positionStatus = $addWindow.find('#positionStatus');

        $.get('/Employee/AvailableFunctions', { parentId: parentId, junction: junction }, function (functions) {
            functions.forEach(f => {
                $functionSelect.append(`<option value="${f.Id}">${f.Nome}</option>`);
            });
        });

        const validateForm = () => {
            const isPositionSelected = $functionSelect.val() !== "";
            $confirmButton.prop('disabled', !isPositionSelected);
        };

        $functionSelect.on('change', validateForm);

        $cancelButton.on('click', function () {
            $addWindow.remove();
        });

        $confirmButton.on('click', function () {
            const positionCode = $functionSelect.val();

            $.post('/Positions/Add', {
                parentId: parentId,
                positionCode: positionCode,
                junction: junction,
                reasonToCreate: $textareaReason,
                positionStatus: $positionStatus
            }, function (response) {
                if (response.success) {
                    renderTree();
                }
                $addWindow.remove();
            });
        });

        $addWindow.draggable({
            containment: '#container',
            scroll: false,
            snap: true,
            snapMode: 'inner',
            snapTolerance: 20
        });
    }

    window.PlatformCanvas.openFillPositionWindow = function(positionCode, roleName, parentId, junction) {
        $('#fill-position-window').remove();

        const fillWindow = $(`
            <div id="fill-position-window">
                <h5>Preencher posição de ${roleName}</h5>
                <label for="candidateSelect" class="noSelect">Selecione um candidato:</label>
                <select class="form-select candidate-select" id="candidateSelect">
                    <option value="">-- Selecione --</option>
                </select>
                <div class="d-flex justify-content-between mt-3">
                    <button type="button" class="btn btn-success confirm-button" disabled>
                        <i class="bi bi-check"></i> Confirmar
                    </button>
                    <button type="button" class="btn btn-danger cancel-button">
                        <i class="bi bi-x"></i> Cancelar
                    </button>
                </div>
            </div>
        `);

        $('#container').append(fillWindow);
        $('#fill-position-window').toggle();

        const $fillWindow = $('#fill-position-window');
        const $candidateSelect = $fillWindow.find('.candidate-select');
        const $confirmButton = $fillWindow.find('.confirm-button');
        const $cancelButton = $fillWindow.find('.cancel-button');

        $.get('/Employee/Candidates', { parentId: parentId, junction: junction }, function (candidates) {
            candidates.forEach(candidate => {
                $candidateSelect.append(`<option value="${candidate.FunctionalCode}">${candidate.FunctionalCode} - ${candidate.Name}</option>`);
            });
        });

        $candidateSelect.on('change', function () {
            $confirmButton.prop('disabled', $(this).val() === "");
        });

        $cancelButton.on('click', function () {
            $fillWindow.remove();
        });

        $confirmButton.on('click', function () {
            const candidateId = $candidateSelect.val();

            $.post('/api/positions/fill', {
                positionCode: positionCode,
                candidateId: candidateId
            }, function (response) {
                if (response.success) {
                    alert('Posição preenchida com sucesso!');
                    renderTree();
                } else {
                    alert('Erro ao preencher posição: ' + response.message);
                }
                $fillWindow.remove();
            });
        });

        $fillWindow.draggable({
            containment: '#container',
            scroll: false,
            snap: true,
            snapMode: 'inner',
            snapTolerance: 20
        });
    }

    window.PlatformCanvas.getRoleFromPositionCode = function(positionCode) {
        const codePrefix = Math.floor(positionCode / 100000000); // Codigo inicial de 2 digitos da posição + Juncao (4 digitos) + 3 digitos de auto-increment

        switch (codePrefix) {
            case 99: return 'PlatformManager';
            case 98: return 'ManagementManager';
            case 97: return 'RelationshipManager';
            case 96: return 'Assistant';
            default: return 'Other';
        }
    }

    window.PlatformCanvas.createEmployeeCard = function(employee) {
        const group = new Konva.Group({
            draggable: false
        });

        group.employeeData = employee;

        const role = employee.Role;
        const isVacant = !employee.Occupant?.Name;
        const cardColor = isVacant ?window.PlatformCanvas.config.card.isVacant.fill :window.PlatformCanvas.config.card.fill[role] ||window.PlatformCanvas.config.card.fill.Diff;
        let infoButton = null;
        let infoText = null;

        const rect = new Konva.Rect({
            width:window.PlatformCanvas.config.nodeWidth,
            height:window.PlatformCanvas.config.nodeHeight,
            fill: cardColor,
            stroke: employee.IsHub ?window.PlatformCanvas.config.isHub.stroke.color :window.PlatformCanvas.config.card.stroke.color,
            strokeWidth: employee.IsHub ?window.PlatformCanvas.config.isHub.stroke.width :window.PlatformCanvas.config.card.stroke.width,
            cornerRadius:window.PlatformCanvas.config.card.cornerRadius,
            shadowColor: 'black',
            shadowBlur:window.PlatformCanvas.config.card.shadow.blur,
            shadowOpacity:window.PlatformCanvas.config.card.shadow.opacity,
            perfectDrawEnabled: false,
            name: 'card-rect'
        });

        const displayName = employee.Occupant?.Name || (isVacant ?window.PlatformCanvas.config.card.isVacant.text.content : '');

        const text = new Konva.Text({
            text: isVacant ?window.PlatformCanvas.config.card.isVacant.text.content : `${displayName}\n${role}`,
            fontSize:window.PlatformCanvas.config.card.text.fontSize,
            fontStyle: isVacant ?window.PlatformCanvas.config.card.isVacant.text.fontStyle :window.PlatformCanvas.config.card.text.fontStyle,
            width:window.PlatformCanvas.config.nodeWidth,
            height:window.PlatformCanvas.config.nodeHeight,
            align:window.PlatformCanvas.config.card.text.align,
            verticalAlign:window.PlatformCanvas.config.card.text.verticalAlign,
            padding: 8,
            fill:window.PlatformCanvas.config.card.text.color
        });

        group.add(rect);
        group.add(text);

        if (employee.IsHub && employee.HubName) {
            const hubText = new Konva.Text({
                text: employee.HubName,
                fontSize:window.PlatformCanvas.config.isHub.text.fontSize,
                fontFamily:window.PlatformCanvas.config.isHub.text.fontFamily,
                fill:window.PlatformCanvas.config.isHub.text.color,
                align:window.PlatformCanvas.config.isHub.text.align,
                width:window.PlatformCanvas.config.nodeWidth - 10,
                padding:window.PlatformCanvas.config.isHub.text.padding,
                fontStyle:window.PlatformCanvas.config.isHub.text.fontStyle
            });

            hubText.position({
                x: 5,
                y: 5
            });

            group.add(hubText);
        }

        if (!isVacant) {
            infoButton = new Konva.Rect({
                x: window.PlatformCanvas.config.nodeWidth / 2,
                y: 0,
                width: window.PlatformCanvas.config.nodeWidth / 2,
                height: window.PlatformCanvas.config.nodeHeight,
                fill: window.PlatformCanvas.config.card.infoButton.fill,
                visible: false,
                name: window.PlatformCanvas.config.card.infoButton.name
            });

            infoText = new Konva.Text({
                text: window.PlatformCanvas.config.card.infoButton.infoText.text,
                fontSize: window.PlatformCanvas.config.card.infoButton.infoText.fontSize,
                fill: window.PlatformCanvas.config.card.infoButton.infoText.fill,
                x: window.PlatformCanvas.config.nodeWidth * 0.75 - 5,
                y: window.PlatformCanvas.config.nodeHeight / 2 - 10,
                visible: false,
                name: window.PlatformCanvas.config.card.infoButton.infoText.name
            });

            group.add(infoButton);
            group.add(infoText);

            infoButton.on('click', () => {
                window.PlatformCanvas.openEmployeeModal(employee);
            });
            infoText.on('click', () => {
                window.PlatformCanvas.openEmployeeModal(employee);
            });
        } else {
            group.on('click', () => {
                window.PlatformCanvas.openFillPositionWindow(employee.PositionCode, employee.Role, employee.Function.ParentID, employee.Junction);
            });
        }

        if (employee.IsHub) {
            rect.stroke(window.PlatformCanvas.config.isHub.stroke.color);
            group.setAttr('isHub', true);
        }

        const hoverGroup = window.PlatformCanvas.config.card.line.hover.width;
        const unhoverGroup = window.PlatformCanvas.config.card.line.unhover.width;
        const shadowBlurHover = window.PlatformCanvas.config.card.line.hover.shadowBlur;
        const shadowBlurUnhover = window.PlatformCanvas.config.card.line.unhover.shadowBlur;

        group.on('mouseenter', () => {
           window.PlatformCanvas.stage.container().style.cursor = 'pointer';
            rect.shadowBlur(shadowBlurHover);
            rect.strokeWidth(hoverGroup);
            if (!isVacant) {
                infoButton.visible(true);
                infoText.visible(true);
            }
           window.PlatformCanvas.layer.batchDraw();
        });

        group.on('mouseleave', () => {
           window.PlatformCanvas.stage.container().style.cursor = 'move';
            rect.shadowBlur(shadowBlurUnhover);
            rect.strokeWidth(unhoverGroup);
            if (!isVacant) {
                infoButton.visible(false);
                infoText.visible(false);
            }
           window.PlatformCanvas.layer.batchDraw();
        });

        return group;
    }

    window.PlatformCanvas.openEmployeeModal = function(employee) {
        alert(`(Modal) Informações sobre ${employee.Name || 'Carteira Vazia'}:\nRole: ${employee.Role}`);
    }

    window.PlatformCanvas.drawConnections = function (parentNode, childNodes) {
        if (!childNodes || childNodes.length === 0) return;

        const parentX = parentNode.x() + window.PlatformCanvas.config.nodeWidth / 2;
        const parentY = parentNode.y() + window.PlatformCanvas.config.nodeHeight;

        childNodes.forEach(child => {
            const childX = child.x() + window.PlatformCanvas.config.nodeWidth / 2;
            const childY = child.y();

            const isParentHub = parentNode.getAttr('isHub') === true;
            const isChildHub = child.getAttr('isHub') === true;
            const bothAreHubs = isParentHub && isChildHub;

            const lineColor = bothAreHubs ? window.PlatformCanvas.config.isHub.stroke.color : window.PlatformCanvas.config.lineColor;
            const lineWidth = bothAreHubs ? window.PlatformCanvas.config.isHub.stroke.width : window.PlatformCanvas.config.lineWidth;

            const line = new Konva.Line({
                points: [parentX, parentY, childX, childY],
                stroke: lineColor,
                strokeWidth: lineWidth,
                lineCap: 'round'
            });

           window.PlatformCanvas.layer.add(line);
        });
    }

    window.PlatformCanvas.addGG = function(parentNode) {
        orgData.Subordinates.push({
            Role: parentNode.Function.Nome,
            Hub: false,
            ParentID: parentNode.Function.ID,
            Subordinates: []
        });
        window.PlatformCanvas.renderTree();
    }

    window.PlatformCanvas.addGR = function(parentNode) {
        const newGR = {
            Role: parentNode.Function.Nome,
            IsHub: parentNode.IsHub,
            HubName: parentNode.HubName,
            ParentID: parentNode.Function.ID,
            Subordinates: []
        };
        parentNode.Subordinates.push(newGR);

        window.PlatformCanvas.renderTree();
    }

    window.PlatformCanvas.addAS = function(parentNode) {
        if (parentNode.Subordinates.length === 0) {
            const newAS = {
                Role: parentNode.Function.Nome,
                Hub: parentNode.IsHub,
                HubName: parentNode.HubName,
                ParentID: parentNode.Function.ID
            };

            parentNode.Subordinates.push(newAS);

            window.PlatformCanvas.renderTree();
        }
    }

    window.PlatformCanvas.calculateSubtreeWidth = function(node, level) {
        if (!node.Subordinates || node.Subordinates.length === 0) {
            return window.PlatformCanvas.config.nodeWidth;
        }

        let totalWidth = 0;
        node.Subordinates.forEach(child => {
            totalWidth += window.PlatformCanvas.calculateSubtreeWidth(child, level + 1) +window.PlatformCanvas.config.minHorizontalSpacing;
        });

        if (level === 0 || (level === 1 && node.Subordinates.length < 5)) {
            totalWidth += window.PlatformCanvas.config.minHorizontalSpacing;
        }

        return totalWidth - window.PlatformCanvas.config.minHorizontalSpacing;
    }

    window.PlatformCanvas.drawTree = function(node, startX, y, level = 0) {
        const subtreeWidth = window.PlatformCanvas.calculateSubtreeWidth(node, level);
        const x = startX + (subtreeWidth - window.PlatformCanvas.config.nodeWidth) / 2;

        let adjustedY = y;
        let attempts = 0;
        while (checkCollision(x, adjustedY, level) && attempts < 10) {
            adjustedY += window.PlatformCanvas.config.nodeHeight / 2;
            attempts++;
        }

        const nodeGroup = createEmployeeCard(node);
        nodeGroup.position({ x, y: adjustedY });

        nodeGroup.employee = () => node;

       window.PlatformCanvas.layer.add(nodeGroup);

        if (node.Subordinates && node.Subordinates.length > 0) {
            const children = [];
            let currentX = startX;

            node.Subordinates.forEach(child => {
                const childSubtreeWidth = window.PlatformCanvas.calculateSubtreeWidth(child, level + 1);
                const childGroup = window.PlatformCanvas.drawTree(child, currentX, adjustedY +window.PlatformCanvas.config.nodeHeight +window.PlatformCanvas.config.verticalSpacing, level + 1);
                children.push(childGroup);
                currentX += childSubtreeWidth +window.PlatformCanvas.config.minHorizontalSpacing;
            });

            window.PlatformCanvas.drawConnections(nodeGroup, children);
        }

        if (level === 0 && node.Function.ParentID === 0) {
            window.PlatformCanvas.createAddButton(
               window.PlatformCanvas.layer.
                x,
                adjustedY,
               window.PlatformCanvas.config.nodeWidth,
               window.PlatformCanvas.config.nodeHeight,
                () => window.PlatformCanvas.addGG(node),
                'left',
                node
            );
        } else if (level === 1 && window.PlatformCanvas.getRoleFromPositionCode(node.PositionCode) === "ManagementManager") {
            window.PlatformCanvas.createAddButton(
               window.PlatformCanvas.layer.
                x,
                adjustedY,
               window.PlatformCanvas.config.nodeWidth,
               window.PlatformCanvas.config.nodeHeight,
                () => window.PlatformCanvas.addGR(node),
                'left',
                node
            );
        } else if (level === 2 && (!node.Subordinates || node.Subordinates.length === 0) &&
            window.PlatformCanvas.getRoleFromPositionCode(node.PositionCode) === "RelationshipManager") {
            window.PlatformCanvas.createAddButton(
               window.PlatformCanvas.layer.
                x,
                adjustedY,
               window.PlatformCanvas.config.nodeWidth,
               window.PlatformCanvas.config.nodeHeight,
                () => window.PlatformCanvas.addAS(node),
                'bottom',
                node
            );
        }

        return nodeGroup;
    }

    window.PlatformCanvas.calculateSubtreeHeight = function (node) {
        const children = node.children || node.Subordinates || [];
        if (children.length === 0) {
            return window.PlatformCanvas.config.nodeHeight;
        }

        let height = 0;
        for (const child of children) {
            height += window.PlatformCanvas.calculateSubtreeHeight(child) +window.PlatformCanvas.config.verticalSpacing;
        }

        return height -window.PlatformCanvas.config.verticalSpacing;
    }

    window.PlatformCanvas.drawConnectionsHorizontal = function (parentCard, childCards) {
        if (!childCards || childCards.length === 0) return;

        const parentX = parentCard.x() +window.PlatformCanvas.config.nodeWidth;
        const parentY = parentCard.y() +window.PlatformCanvas.config.nodeHeight / 2;

        childCards.forEach(child => {
            const childX = child.x();
            const childY = child.y() +window.PlatformCanvas.config.nodeHeight / 2;

            const isParentHub = parentCard.getAttr('isHub') === true;
            const isChildHub = child.getAttr('isHub') === true;
            const bothAreHubs = isParentHub && isChildHub;

            const lineColor = bothAreHubs ?window.PlatformCanvas.config.isHub.stroke.color :window.PlatformCanvas.config.lineColor;
            const lineWidth = bothAreHubs ?window.PlatformCanvas.config.isHub.stroke.width :window.PlatformCanvas.config.lineWidth;

            const line = new Konva.Line({
                points: [parentX, parentY, childX, childY],
                stroke: lineColor,
                strokeWidth: lineWidth,
                lineCap: 'round',
                lineJoin: 'round'
            });

           window.PlatformCanvas.layer.add(line);
        });
    }

    window.PlatformCanvas.drawTreeHorizontal = function (node, parent = null, level = 0, posY = 0, posX = 0) {
        if (!node) return;

        const card = window.PlatformCanvas.createEmployeeCard(node);

        const adjustedX = posX;
        let adjustedY = posY;

        while (window.PlatformCanvas.checkCollisionHorizontal(adjustedX, adjustedY, level)) {
            adjustedY +=window.PlatformCanvas.config.nodeHeight + window.PlatformCanvas.config.verticalSpacing;
        }

        card.position({ x: adjustedX, y: adjustedY });
        window.PlatformCanvas.layer.add(card);

        if (parent && parent.card) {
            window.PlatformCanvas.drawConnectionsHorizontal(parent.card, [card]);
        }

        const children = node.children || node.Subordinates || [];
        const spacing = window.PlatformCanvas.config.nodeWidth * 2;

        let totalChildHeight = 0;
        const childrenHeights = [];

        for (const child of children) {
            const h = window.PlatformCanvas.calculateSubtreeHeight(child);
            childrenHeights.push(h);
            totalChildHeight += h;
        }
        totalChildHeight += (children.length - 3) * window.PlatformCanvas.config.verticalSpacing;

        let childY = adjustedY - totalChildHeight / 2;

        for (let i = 0; i < children.length; i++) {
            const child = children[i];
            window.PlatformCanvas.drawTreeHorizontal(
                child,
                { node, card },
                level + 1,
                childY,
                adjustedX + spacing
            );
            childY += childrenHeights[i] + window.PlatformCanvas.config.verticalSpacing;
        }

        if (level === 0 && node.Function?.ParentID === 0) {
            window.PlatformCanvas.createAddButton(window.PlatformCanvas.layer, adjustedX, adjustedY, window.PlatformCanvas.config.nodeWidth, window.PlatformCanvas.config.nodeHeight,
                () => window.PlatformCanvas.addGG(), 'bottom', card);
        }
        else if (level === 1 && window.PlatformCanvas.getRoleFromPositionCode(node.PositionCode) === "ManagementManager") {
            window.PlatformCanvas.createAddButton(window.PlatformCanvas.layer, adjustedX, adjustedY, window.PlatformCanvas.config.nodeWidth, window.PlatformCanvas.config.nodeHeight,
                () => window.PlatformCanvas.addGR(node), 'bottom', card);
        }
        else if (level === 2 && (!node.Subordinates || node.Subordinates.length === 0) &&
            window.PlatformCanvas.getRoleFromPositionCode(node.PositionCode) === "RelationshipManager") {
            window.PlatformCanvas.createAddButton(window.PlatformCanvas.layer, adjustedX, adjustedY, window.PlatformCanvas.config.nodeWidth, window.PlatformCanvas.config.nodeHeight,
                () => window.PlatformCanvas.addAS(node), 'right', card);
        }
    }

    window.PlatformCanvas.renderTree = function () {
        window.PlatformCanvas.layer.destroyChildren();
        window.PlatformCanvas.occupiedPositions.clear();

        const stageWidth = window.PlatformCanvas.stage.width();
        const stageHeight = window.PlatformCanvas.stage.height();

        const startX = stageWidth / 2;
        const startY = stageHeight / 2;

        if (window.PlatformCanvas.config.orientation === 'horizontal') {
            window.PlatformCanvas.drawTree(window.PlatformCanvas.orgData, startX, startY);
        } else if (window.PlatformCanvas.config.orientation === 'vertical') {
            window.PlatformCanvas.drawTreeHorizontal(window.PlatformCanvas.orgData, null, 0, startX, startY);
        }

        window.PlatformCanvas.centerContent();

        window.PlatformCanvas.layer.batchDraw();
        window.konvaInitialized = true;
    }

    window.PlatformCanvas.centerContent = function () {
        window.PlatformCanvas.stage.scale({ x: 1, y: 1 });
        window.PlatformCanvas.layer.position({ x: 0, y: 0 });

        window.PlatformCanvas.layer.batchDraw();

        const contentBounds = window.PlatformCanvas.layer.getClientRect();

        const stageCenterX =window.PlatformCanvas.stage.width() / 2;
        const stageCenterY =window.PlatformCanvas.stage.height() / 2;

        const contentCenterX = contentBounds.x + contentBounds.width / 4;
        const contentCenterY = contentBounds.y + contentBounds.height / 4;

        const offsetX = stageCenterX - contentCenterX;
        const offsetY = stageCenterY - contentCenterY;

        window.PlatformCanvas.layer.position({
            x: offsetX,
            y: offsetY
        });

        window.PlatformCanvas.fitStageToTree();

        window.PlatformCanvas.layer.batchDraw();
    }

    window.PlatformCanvas.fitStageToTree = function () {
        const treeBounds = window.PlatformCanvas.layer.getClientRect();
        const scale = Math.min(
            (window.PlatformCanvas.stage.width() - 100) / treeBounds.width,
            (window.PlatformCanvas.stage.height() - 100) / treeBounds.height
        );

        window.PlatformCanvas.stage.scale({ x: scale, y: scale });
        window.PlatformCanvas.stage.position({
            x: (window.PlatformCanvas.stage.width() - treeBounds.width * scale) / 2 - treeBounds.x * scale,
            y: 20
        });
        window.PlatformCanvas.stage.batchDraw();
    }

    window.PlatformCanvas.zoom = function (factor) {
        const oldScale = window.PlatformCanvas.stage.scaleX();
        const newScale = oldScale * factor;
        const pointer = window.PlatformCanvas.stage.getPointerPosition();

        if (!pointer) {
            window.PlatformCanvas.stage.scale({ x: newScale, y: newScale });
            window.PlatformCanvas.stage.batchDraw();
            return;
        }

        const mousePointTo = {
            x: (pointer.x - window.PlatformCanvas.stage.x()) / oldScale,
            y: (pointer.y - window.PlatformCanvas.stage.y()) / oldScale,
        };

        window.PlatformCanvas.stage.scale({ x: newScale, y: newScale });
        window.PlatformCanvas.stage.position({
            x: pointer.x - mousePointTo.x * newScale,
            y: pointer.y - mousePointTo.y * newScale,
        });
        window.PlatformCanvas.stage.batchDraw();
    }

    window.PlatformCanvas.toggleFullscreen = function () {
        const el = document.getElementById('container');
        if (!document.fullscreenElement) {
            el.requestFullscreen().then(window.PlatformCanvas.updateStageSize);
        } else {
            document.exitFullscreen().then(window.PlatformCanvas.updateStageSize);
        }
    }

    window.PlatformCanvas.toggleOrientation = function () {
       window.PlatformCanvas.config.orientation =window.PlatformCanvas.config.orientation === 'horizontal' ? 'vertical' : 'horizontal';
       window.PlatformCanvas.renderTree();
    }

    window.PlatformCanvas.updateStageSize = function () {
       window.PlatformCanvas.stage.width(container.clientWidth);
       window.PlatformCanvas.stage.height(container.clientHeight);
       window.PlatformCanvas.renderTree();
    }

    window.PlatformCanvas.initialize = function () {
        window.PlatformCanvas.renderTree();
        window.PlatformCanvas.stage.container().style.cursor = 'move';
        console.log(window.PlatformCanvas);
    };

    window.PlatformCanvas.stage.on('wheel', (e) => {
        e.evt.preventDefault();
        window.PlatformCanvas.zoom(e.evt.deltaY < 0 ? 1.05 : 0.95);
    });

    window.addEventListener('resize', window.PlatformCanvas.updateStageSize);

    window.onload = window.PlatformCanvas.initialize();
</script>