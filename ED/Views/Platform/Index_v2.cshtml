@model dynamic

<style>
    #tree-container {
        width: 100%;
        height: 100%;
        background-color: #f5f5f5;
    }

    #button-container {
        position: absolute;
        top: 10px;
        right: 10px;
        display: flex;
        gap: 10px;
        flex-direction: column;
    }

    #fill-position-window {
        position: absolute;
        bottom: 50%;
        left: 50%;
        background: white;
        padding: 20px;
        border-radius: 10px;
        box-shadow: 0px 0px 10px rgba(0, 0, 0, 0.3);
        display: none;
        width: 400px;
        height: fit-content;
        z-index: 100;
        text-align: center;
    }

        #fill-position-window select {
            width: 100%;
            margin-top: 10px;
            display: ruby;
        }

    #add-employee-window {
        position: absolute;
        bottom: 50%;
        left: 50%;
        background: white;
        padding: 20px;
        border-radius: 10px;
        box-shadow: 0px 0px 10px rgba(0, 0, 0, 0.3);
        display: none;
        width: 400px;
        height: fit-content;
        z-index: 100;
        text-align: center;
    }

        #add-employee-window select,
        #add-employee-window input {
            width: 100%;
            margin-top: 10px;
            display: ruby;
        }
</style>

<div id="container" style="position: relative; width: 100%; height: 100%;">
    <div id="tree-container"></div>
    <div id="button-container">
        <button type="button" title="Zoom In" class="btn" onclick="zoom(1.1)"><i class="bi bi-zoom-in"></i></button>
        <button type="button" title="Zoom Out" class="btn" onclick="zoom(0.9)"><i class="bi bi-zoom-out"></i></button>
        <button type="button" title="Fullscreen" class="btn" onclick="toggleFullscreen()"><i class="bi bi-fullscreen"></i></button>
        <button type="button" title="Girar" class="btn" onclick="toggleOrientation()"><i class="bi bi-arrow-clockwise"></i></button>
    </div>
</div>

<script>
    // Configurações globais
    const config = {
        orientation: 'vertical',
        nodeWidth: 200,
        nodeHeight: 200,
        minHorizontalSpacing: 50,
        verticalSpacing: 100,
        card: {
            cornerRadius: 4,
            shadow: {
                blur: 5,
                opacity: 0.2
            },
            isVacant: {
                fill: '#e04f60',
                text: {
                    content: "Clique aqui para preencher a posição",
                    fontStyle: 'normal'
                },
            },
            fill: {
                'PlatformManager': '#cc092f',
                'ManagementManager': '#e03c50',
                'RelationshipManager': '#e03c50',
                'Assistant': '#e03c50',
                'Diff': '#e04f60'
            },
            text: {
                color: '#fff',
                fontSize: 12,
                align: 'center',
                verticalAlign: 'middle',
                fontStyle: 'bold'
            },
            infoButton: {
                fill: 'rgba(52, 152, 219, 0.5)',
                name: 'info-button',
                infoText: {
                    fill: 'white',
                    name: 'info-text',
                    text: 'i',
                    fontSize: 20
                }
            },
            line: {
                hover: {
                    width: 3,
                    color: '',
                    shadowBlur: 10,
                },
                unhover: {
                    width: 2,
                    color: '',
                    shadowBlur: 5,
                },
            },
            stroke: {
                color: '#ecf0f1',
                width: 2
            }
        },
        lineColor: '#7f8c8d',
        isHub: {
            stroke: {
                color: '#2ecc71',
                width: 3
            },
            text: {
                align: 'left',
                color: '#2ecc71',
                fontSize: 14,
                fontStyle: 'bold',
                padding: 5,
                fontFamily: 'Calibri'
            }
        },
        addButton: {
            size: 20,
            lineLength: 30,
            strokeColor: 'black',
            backGround: {
                hover: '#dee2e6',
                natural: 'transparent'
            },
            icon: {
                fill: 'black',
                align: 'center',
                text: '\uF4FE',
                fontSize: 18,
                fontFamily: 'bootstrap-icons'
            }
        }
    };

    const orgData = @Html.Raw(Json.Encode(Model));

    const container = document.getElementById('tree-container');
    const stage = new Konva.Stage({
        container: 'tree-container',
        width: container.clientWidth,
        height: container.clientHeight,
        draggable: true
    });

    const layer = new Konva.Layer();
    stage.add(layer);

    const occupiedPositions = new Map();

    function checkCollision(x, y, level) {
        const key = `${level}-${x.toFixed(0)}`;
        if (occupiedPositions.has(key)) {
            const existingY = occupiedPositions.get(key);
            if (Math.abs(existingY - y) < config.nodeHeight + 20) {
                return true;
            }
        }
        occupiedPositions.set(key, y);
        return false;
    }

    function checkCollisionHorizontal(x, y, level) {
        const key = `${level}-${y.toFixed(0)}`;
        if (occupiedPositions.has(key)) {
            const existingX = occupiedPositions.get(key);
            if (Math.abs(existingX - x) < config.nodeWidth + 20) {
                return true;
            }
        }
        occupiedPositions.set(key, x);
        return false;
    }

    function createAddButton(parentGroup, parentX, parentY, parentWidth, parentHeight, onClick, position = 'bottom') {
        const buttonGroup = new Konva.Group({ draggable: false, name: 'add-employee-button' });

        let buttonX, buttonY, linePoints;

        switch (position) {
            case 'left':
                buttonX = parentX - config.addButton.size - 30;
                buttonY = parentY + parentHeight / 2;

                linePoints = [
                    parentX, buttonY,
                    buttonX + config.addButton.size - 10, buttonY
                ];
                break;

            case 'right':
                buttonX = parentX + parentWidth + config.addButton.size + 30;
                buttonY = parentY + parentHeight / 2;

                linePoints = [
                    parentX + parentWidth, buttonY,
                    buttonX - config.addButton.size + 10, buttonY
                ];
                break;

            case 'top':
                buttonX = parentX + parentWidth / 2;
                buttonY = parentY - config.addButton.lineLength;

                linePoints = [
                    buttonX, parentY,
                    buttonX, buttonY + config.addButton.size / 2
                ];
                break;

            default: // bottom (default)
                buttonX = parentX + parentWidth / 2;
                buttonY = parentY + parentHeight + config.addButton.lineLength;

                linePoints = [
                    buttonX, parentY + parentHeight,
                    buttonX, buttonY - config.addButton.size / 2
                ];
        }

        const line = new Konva.Line({
            points: linePoints,
            stroke: config.lineColor,
            strokeWidth: config.lineWidth,
            lineCap: 'round'
        });

        const circle = new Konva.Circle({
            x: buttonX,
            y: buttonY,
            radius: config.addButton.size / 2,
            fill: config.addButton.backGround.natural,
            stroke: config.addButton.strokeColor,
            strokeWidth: 1,

        });

        const plusIcon = new Konva.Text({
            x: buttonX - 9,
            y: buttonY - 10,
            text: config.addButton.icon.text,
            fontFamily: config.addButton.icon.fontFamily,
            fontSize: config.addButton.icon.fontSize,
            fill: config.addButton.icon.fill,
            align: config.addButton.icon.align
        });

        buttonGroup.add(line);
        buttonGroup.add(circle);
        buttonGroup.add(plusIcon);

        buttonGroup.on('mouseenter', () => {
            stage.container().style.cursor = 'pointer';
            circle.fill(config.addButton.backGround.hover);
            layer.batchDraw();
        });

        buttonGroup.on('mouseleave', () => {
            stage.container().style.cursor = 'move';
            circle.fill(config.addButton.color);
            layer.batchDraw();
        });

        buttonGroup.on('click', (e) => {
            e.cancelBubble = true;
            const parentNode = parentGroup.findOne('.card-rect').getParent().employeeData;
            openAddEmployeeWindow(
                parentNode.Function.ParentID,
                parentNode.PositionCode,
                parentNode.Junction
            );
        });

        layer.add(buttonGroup);
        return buttonGroup;
    }

    function openAddEmployeeWindow(parentId, positionCode, junction) {
        $('#add-employee-window').remove();

        const addWindow = $(`
            <div id="add-employee-window">
                <h5>Adicionar uma nova posição</h5>
                <label for="positionSelect" class="noSelect">Selecione uma função:</label>
                <select class="form-select position-select" id="positionSelect">
                    <option value="">-- Selecione --</option>
                </select>
                <div class="d-flex justify-content-between mt-3">
                    <button type="button" class="btn btn-success confirm-button" disabled>
                        <i class="bi bi-check"></i> Confirmar
                    </button>
                    <button type="button" class="btn btn-danger cancel-button">
                        <i class="bi bi-x"></i> Cancelar
                    </button>
                </div>
            </div>
        `);

        $('#container').append(addWindow);
        $('#add-employee-window').toggle();

        const $addWindow = $('#add-employee-window');
        const $positionSelect = $addWindow.find('.position-select');
        const $confirmButton = $addWindow.find('.confirm-button');
        const $cancelButton = $addWindow.find('.cancel-button');

        $.get('/Employee/AvailableFunctions', { parentId: parentId, junction: junction }, function (functions) {
            functions.forEach(f => {
                $positionSelect.append(`<option value="${f.Id}">${f.Nome}</option>`);
            });
        });

        const validateForm = () => {
            const isPositionSelected = $positionSelect.val() !== "";
            $confirmButton.prop('disabled', !isPositionSelected);
        };

        $positionSelect.on('change', validateForm);

        $cancelButton.on('click', function () {
            $addWindow.remove();
        });

        $confirmButton.on('click', function () {
            const positionCode = $positionSelect.val();

            $.post('/api/positions/add', {
                parentId: parentId,
                positionCode: positionCode,
                junction: junction
            }, function (response) {
                if (response.success) {
                    alert('Funcionário adicionado com sucesso!');
                    renderTree();
                } else {
                    alert('Erro ao adicionar funcionário: ' + response.message);
                }
                $addWindow.remove();
            });
        });

        $addWindow.draggable({
            containment: '#container',
            scroll: false,
            snap: true,
            snapMode: 'inner',
            snapTolerance: 20
        });
    }

    function openFillPositionWindow(positionCode, roleName, parentId, junction) {
        $('#fill-position-window').remove();

        const fillWindow = $(`
            <div id="fill-position-window">
                <h5>Preencher posição de ${roleName}</h5>
                <label for="candidateSelect" class="noSelect">Selecione um candidato:</label>
                <select class="form-select candidate-select" id="candidateSelect">
                    <option value="">-- Selecione --</option>
                </select>
                <div class="d-flex justify-content-between mt-3">
                    <button type="button" class="btn btn-success confirm-button" disabled>
                        <i class="bi bi-check"></i> Confirmar
                    </button>
                    <button type="button" class="btn btn-danger cancel-button">
                        <i class="bi bi-x"></i> Cancelar
                    </button>
                </div>
            </div>
        `);

        $('#container').append(fillWindow);
        $('#fill-position-window').toggle();

        const $fillWindow = $('#fill-position-window');
        const $candidateSelect = $fillWindow.find('.candidate-select');
        const $confirmButton = $fillWindow.find('.confirm-button');
        const $cancelButton = $fillWindow.find('.cancel-button');

        $.get('/Employee/Candidates', { parentId: parentId, junction: junction }, function (candidates) {
            candidates.forEach(candidate => {
                $candidateSelect.append(`<option value="${candidate.FunctionalCode}">${candidate.FunctionalCode} - ${candidate.Name}</option>`);
            });
        });

        $candidateSelect.on('change', function () {
            $confirmButton.prop('disabled', $(this).val() === "");
        });

        $cancelButton.on('click', function () {
            $fillWindow.remove();
        });

        $confirmButton.on('click', function () {
            const candidateId = $candidateSelect.val();

            $.post('/api/positions/fill', {
                positionCode: positionCode,
                candidateId: candidateId
            }, function (response) {
                if (response.success) {
                    alert('Posição preenchida com sucesso!');
                    renderTree();
                } else {
                    alert('Erro ao preencher posição: ' + response.message);
                }
                $fillWindow.remove();
            });
        });

        $fillWindow.draggable({
            containment: '#container',
            scroll: false,
            snap: true,
            snapMode: 'inner',
            snapTolerance: 20
        });
    }

    function getRoleFromPositionCode(positionCode) {
        const codePrefix = Math.floor(positionCode / 10000000);

        switch (codePrefix) {
            case 99: return 'PlatformManager';
            case 98: return 'ManagementManager';
            case 97: return 'RelationshipManager';
            case 96: return 'Assistant';
            default: return 'Other';
        }
    }

    function createEmployeeCard(employee, level) {
        const group = new Konva.Group({
            draggable: false
        });

        group.employeeData = employee;

        const role = employee.Role;
        const isVacant = !employee.Occupant?.Name;
        const cardColor = isVacant ? config.card.isVacant.fill : config.card.fill[role] || config.card.fill.Diff;
        let infoButton = null;
        let infoText = null;

        const rect = new Konva.Rect({
            width: config.nodeWidth,
            height: config.nodeHeight,
            fill: cardColor,
            stroke: employee.IsHub ? config.isHub.stroke.color : config.card.stroke.color,
            strokeWidth: employee.IsHub ? config.isHub.stroke.width : config.card.stroke.width,
            cornerRadius: config.card.cornerRadius,
            shadowColor: 'black',
            shadowBlur: config.card.shadow.blur,
            shadowOpacity: config.card.shadow.opacity,
            perfectDrawEnabled: false,
            name: 'card-rect'
        });

        const displayName = employee.Occupant?.Name || (isVacant ? config.card.isVacant.text.content : '');

        const text = new Konva.Text({
            text: isVacant ? config.card.isVacant.text.content : `${displayName}\n${role}`,
            fontSize: config.card.text.fontSize,
            fontStyle: isVacant ? config.card.isVacant.text.fontStyle : config.card.text.fontStyle,
            width: config.nodeWidth,
            height: config.nodeHeight,
            align: config.card.text.align,
            verticalAlign: config.card.text.verticalAlign,
            padding: 8,
            fill: config.card.text.color
        });

        group.add(rect);
        group.add(text);

        if (employee.IsHub && employee.HubName) {
            const hubText = new Konva.Text({
                text: employee.HubName,
                fontSize: config.isHub.text.fontSize,
                fontFamily: config.isHub.text.fontFamily,
                fill: config.isHub.text.color,
                align: config.isHub.text.align,
                width: config.nodeWidth - 10,
                padding: config.isHub.text.padding,
                fontStyle: config.isHub.text.fontStyle
            });

            hubText.position({
                x: 5,
                y: 5
            });

            group.add(hubText);
        }

        if (!isVacant) {
            infoButton = new Konva.Rect({
                x: config.nodeWidth / 2,
                y: 0,
                width: config.nodeWidth / 2,
                height: config.nodeHeight,
                fill: config.card.infoButton.fill,
                visible: false,
                name: config.card.infoButton.name
            });

            infoText = new Konva.Text({
                text: config.card.infoButton.infoText.text,
                fontSize: config.card.infoButton.infoText.fontSize,
                fill: config.card.infoButton.infoText.fill,
                x: config.nodeWidth * 0.75 - 5,
                y: config.nodeHeight / 2 - 10,
                visible: false,
                name: config.card.infoButton.infoText.name
            });

            group.add(infoButton);
            group.add(infoText);

            infoButton.on('click', () => {
                openEmployeeModal(employee);
            });
            infoText.on('click', () => {
                openEmployeeModal(employee);
            });
        } else {
            group.on('click', () => {
                openFillPositionWindow(employee.PositionCode, employee.Role, employee.Function.ParentID, employee.Junction);
            });
        }

        if (employee.IsHub) {
            rect.stroke(config.isHub.stroke.color);
            group.setAttr('isHub', true);
        }

        const hoverGroup = config.card.line.hover.width;
        const unhoverGroup = config.card.line.unhover.width;
        const shadowBlurHover = config.card.line.hover.shadowBlur;
        const shadowBlurUnhover = config.card.line.unhover.shadowBlur;

        group.on('mouseenter', () => {
            stage.container().style.cursor = 'pointer';
            rect.shadowBlur(shadowBlurHover);
            rect.strokeWidth(hoverGroup);
            if (!isVacant) {
                infoButton.visible(true);
                infoText.visible(true);
            }
            layer.batchDraw();
        });

        group.on('mouseleave', () => {
            stage.container().style.cursor = 'move';
            rect.shadowBlur(shadowBlurUnhover);
            rect.strokeWidth(unhoverGroup);
            if (!isVacant) {
                infoButton.visible(false);
                infoText.visible(false);
            }
            layer.batchDraw();
        });

        return group;
    }

    function openEmployeeModal(employee) {
        alert(`(Modal) Informações sobre ${employee.Name || 'Carteira Vazia'}:\nRole: ${employee.Role}`);
    }

    function drawConnections(parentNode, childNodes) {
        if (!childNodes || childNodes.length === 0) return;

        const parentX = parentNode.x() + config.nodeWidth / 2;
        const parentY = parentNode.y() + config.nodeHeight;

        childNodes.forEach(child => {
            const childX = child.x() + config.nodeWidth / 2;
            const childY = child.y();

            const isParentHub = parentNode.getAttr('isHub') === true;
            const isChildHub = child.getAttr('isHub') === true;
            const bothAreHubs = isParentHub && isChildHub;

            const lineColor = bothAreHubs ? config.isHub.stroke.color : config.lineColor;
            const lineWidth = bothAreHubs ? config.isHub.stroke.width : config.lineWidth;

            const line = new Konva.Line({
                points: [parentX, parentY, childX, childY],
                stroke: lineColor,
                strokeWidth: lineWidth,
                lineCap: 'round'
            });

            layer.add(line);
        });
    }

    function addGG(parentNode) {
        orgData.Subordinates.push({
            Role: parentNode.Function.Nome,
            Hub: false,
            ParentID: parentNode.Function.ID,
            Subordinates: []
        });
        renderTree();
    }

    function addGR(parentNode) {
        const newGR = {
            Role: parentNode.Function.Nome,
            IsHub: parentNode.IsHub,
            HubName: parentNode.HubName,
            ParentID: parentNode.Function.ID,
            Subordinates: []
        };
        parentNode.Subordinates.push(newGR);

        renderTree();
    }

    function addAS(parentNode) {
        if (parentNode.Subordinates.length === 0) {
            const newAS = {
                Role: parentNode.Function.Nome,
                Hub: parentNode.IsHub,
                HubName: parentNode.HubName,
                ParentID: parentNode.Function.ID
            };

            parentNode.Subordinates.push(newAS);

            renderTree();
        }
    }

    function calculateSubtreeWidth(node, level) {
        if (!node.Subordinates || node.Subordinates.length === 0) {
            return config.nodeWidth;
        }

        let totalWidth = 0;
        node.Subordinates.forEach(child => {
            totalWidth += calculateSubtreeWidth(child, level + 1) + config.minHorizontalSpacing;
        });

        if (level === 0 || (level === 1 && node.Subordinates.length < 5)) {
            totalWidth += config.minHorizontalSpacing;
        }

        return totalWidth - config.minHorizontalSpacing;
    }

    function drawTree(node, startX, y, level = 0) {
        const subtreeWidth = calculateSubtreeWidth(node, level);
        const x = startX + (subtreeWidth - config.nodeWidth) / 2;

        let adjustedY = y;
        let attempts = 0;
        while (checkCollision(x, adjustedY, level) && attempts < 10) {
            adjustedY += config.nodeHeight / 2;
            attempts++;
        }

        const nodeGroup = createEmployeeCard(node, level);
        nodeGroup.position({ x, y: adjustedY });

        nodeGroup.employee = () => node;

        layer.add(nodeGroup);

        if (node.Subordinates && node.Subordinates.length > 0) {
            const children = [];
            let currentX = startX;

            node.Subordinates.forEach(child => {
                const childSubtreeWidth = calculateSubtreeWidth(child, level + 1);
                const childGroup = drawTree(child, currentX, adjustedY + config.nodeHeight + config.verticalSpacing, level + 1);
                children.push(childGroup);
                currentX += childSubtreeWidth + config.minHorizontalSpacing;
            });

            drawConnections(nodeGroup, children);
        }

        if (level === 0 && node.Function.ParentID === 0) {
            createAddButton(
                layer,
                x,
                adjustedY,
                config.nodeWidth,
                config.nodeHeight,
                () => addGG(node),
                'left'
            );
        } else if (level === 1 && getRoleFromPositionCode(node.PositionCode) === "ManagementManager") {
            createAddButton(
                layer,
                x,
                adjustedY,
                config.nodeWidth,
                config.nodeHeight,
                () => addGR(node),
                'left'
            );
        } else if (level === 2 && (!node.Subordinates || node.Subordinates.length === 0) &&
            getRoleFromPositionCode(node.PositionCode) === "RelationshipManager") {
            createAddButton(
                layer,
                x,
                adjustedY,
                config.nodeWidth,
                config.nodeHeight,
                () => addAS(node),
                'bottom'
            );
        }

        return nodeGroup;
    }

    function calculateSubtreeHeight(node) {
        const children = node.children || node.Subordinates || [];
        if (children.length === 0) {
            return config.nodeHeight;
        }

        let height = 0;
        for (const child of children) {
            height += calculateSubtreeHeight(child) + config.verticalSpacing;
        }

        return height - config.verticalSpacing;
    }

    function drawConnectionsHorizontal(parentCard, childCards) {
        if (!childCards || childCards.length === 0) return;

        const parentX = parentCard.x() + config.nodeWidth;
        const parentY = parentCard.y() + config.nodeHeight / 2;

        childCards.forEach(child => {
            const childX = child.x();
            const childY = child.y() + config.nodeHeight / 2;

            const isParentHub = parentCard.getAttr('isHub') === true;
            const isChildHub = child.getAttr('isHub') === true;
            const bothAreHubs = isParentHub && isChildHub;

            const lineColor = bothAreHubs ? config.isHub.stroke.color : config.lineColor;
            const lineWidth = bothAreHubs ? config.isHub.stroke.width : config.lineWidth;

            const line = new Konva.Line({
                points: [parentX, parentY, childX, childY],
                stroke: lineColor,
                strokeWidth: lineWidth,
                lineCap: 'round',
                lineJoin: 'round'
            });

            layer.add(line);
        });
    }

    function drawTreeHorizontal(node, parent = null, level = 0, posY = 0, posX = 0) {
        if (!node) return;

        const card = createEmployeeCard(node, level);
        const adjustedX = posX;
        let adjustedY = posY;

        while (checkCollisionHorizontal(adjustedX, adjustedY, level)) {
            adjustedY += config.nodeHeight + config.verticalSpacing;
        }

        card.position({ x: adjustedX, y: adjustedY });
        layer.add(card);

        if (parent && parent.card) {
            drawConnectionsHorizontal(parent.card, [card]);
        }

        const children = node.children || node.Subordinates || [];
        const spacing = config.nodeWidth * 2;

        let totalChildHeight = 0;
        const childrenHeights = [];

        for (const child of children) {
            const h = calculateSubtreeHeight(child);
            childrenHeights.push(h);
            totalChildHeight += h;
        }
        totalChildHeight += (children.length - 3) * config.verticalSpacing;

        let childY = adjustedY - totalChildHeight / 2;

        for (let i = 0; i < children.length; i++) {
            const child = children[i];
            drawTreeHorizontal(
                child,
                { node, card },
                level + 1,
                childY,
                adjustedX + spacing
            );
            childY += childrenHeights[i] + config.verticalSpacing;
        }

        if (level === 0 && node.Function?.ParentID === 0) {
            createAddButton(layer, adjustedX, adjustedY, config.nodeWidth, config.nodeHeight,
                () => addGG(), 'bottom');
        }
        else if (level === 1 && getRoleFromPositionCode(node.PositionCode) === "ManagementManager") {
            createAddButton(layer, adjustedX, adjustedY, config.nodeWidth, config.nodeHeight,
                () => addGR(node), 'bottom');
        }
        else if (level === 2 && (!node.Subordinates || node.Subordinates.length === 0) &&
            getRoleFromPositionCode(node.PositionCode) === "RelationshipManager") {
            createAddButton(layer, adjustedX, adjustedY, config.nodeWidth, config.nodeHeight,
                () => addAS(node), 'right');
        }
    }

    function renderTree() {
        layer.destroyChildren();
        occupiedPositions.clear();

        const stageWidth = stage.width();
        const stageHeight = stage.height();

        const startX = stageWidth / 2;
        const startY = stageHeight / 2;

        if (config.orientation === 'horizontal') {
            drawTree(orgData, startX, startY);
        } else if (config.orientation === 'vertical') {
            drawTreeHorizontal(orgData, null, 0, startX, startY);
        }

        centerContent();

        layer.batchDraw();
        window.konvaInitialized = true;
    }

    function centerContent() {
        stage.scale({ x: 1, y: 1 });
        layer.position({ x: 0, y: 0 });

        layer.batchDraw();

        const contentBounds = layer.getClientRect();

        const stageCenterX = stage.width() / 2;
        const stageCenterY = stage.height() / 2;

        const contentCenterX = contentBounds.x + contentBounds.width / 4;
        const contentCenterY = contentBounds.y + contentBounds.height / 4;

        const offsetX = stageCenterX - contentCenterX;
        const offsetY = stageCenterY - contentCenterY;

        layer.position({
            x: offsetX,
            y: offsetY
        });

        fitStageToTree();

        layer.batchDraw();
    }

    function fitStageToTree() {
        const treeBounds = layer.getClientRect();
        const scale = Math.min(
            (stage.width() - 100) / treeBounds.width,
            (stage.height() - 100) / treeBounds.height
        );

        stage.scale({ x: scale, y: scale });
        stage.position({
            x: (stage.width() - treeBounds.width * scale) / 2 - treeBounds.x * scale,
            y: 20
        });
        stage.batchDraw();
    }

    function zoom(factor) {
        const oldScale = stage.scaleX();
        const newScale = oldScale * factor;
        const pointer = stage.getPointerPosition();

        if (!pointer) {
            stage.scale({ x: newScale, y: newScale });
            stage.batchDraw();
            return;
        }

        const mousePointTo = {
            x: (pointer.x - stage.x()) / oldScale,
            y: (pointer.y - stage.y()) / oldScale,
        };

        stage.scale({ x: newScale, y: newScale });
        stage.position({
            x: pointer.x - mousePointTo.x * newScale,
            y: pointer.y - mousePointTo.y * newScale,
        });
        stage.batchDraw();
    }

    function toggleFullscreen() {
        const el = document.getElementById('container');
        if (!document.fullscreenElement) {
            el.requestFullscreen().then(updateStageSize);
        } else {
            document.exitFullscreen().then(updateStageSize);
        }
    }

    function toggleOrientation() {
        config.orientation = config.orientation === 'horizontal' ? 'vertical' : 'horizontal';
        renderTree();
    }

    function updateStageSize() {
        stage.width(container.clientWidth);
        stage.height(container.clientHeight);
        renderTree();
    }

    stage.on('wheel', (e) => {
        e.evt.preventDefault();
        zoom(e.evt.deltaY < 0 ? 1.05 : 0.95);
    });

    window.addEventListener('resize', updateStageSize);

    window.onload = () => {
        renderTree();
        stage.container().style.cursor = 'move';
    };
</script>